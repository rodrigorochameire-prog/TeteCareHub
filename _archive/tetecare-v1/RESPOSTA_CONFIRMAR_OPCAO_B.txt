Perfeito! A Opção B é a mais segura e evita downtime.

**CONFIRMAÇÃO: Pode prosseguir com a Opção B (criar nova função e migrar políticas).**

Por favor, execute os seguintes passos:

**1. Criar nova função `extract_tutor_id_from_path_bigint`:**
```sql
CREATE OR REPLACE FUNCTION public.extract_tutor_id_from_path_bigint(
  file_path text
) RETURNS bigint
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  path_parts text[];
  tutor_id_str text;
BEGIN
  IF file_path IS NULL OR file_path = '' THEN
    RETURN NULL;
  END IF;
  
  path_parts := string_to_array(file_path, '/');
  
  IF array_length(path_parts, 1) >= 2 THEN
    tutor_id_str := path_parts[2];
    BEGIN
      RETURN tutor_id_str::bigint;
    EXCEPTION WHEN OTHERS THEN
      RETURN NULL;
    END;
  END IF;
  
  RETURN NULL;
END;
$$;
```

**2. Atualizar as 4 políticas para usar a nova função:**

**staff_policy_select:**
```sql
ALTER POLICY "staff_policy_select" ON storage.objects
USING (
  bucket_id = 'staff'::text 
  AND (
    public.is_admin((SELECT auth.uid()))
    OR
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.auth_id = (SELECT auth.uid())
        AND users.id = public.extract_tutor_id_from_path_bigint(storage.objects.name)
    )
  )
);
```

**tutors_policy_select:**
```sql
ALTER POLICY "tutors_policy_select" ON storage.objects
USING (
  bucket_id = 'tutors'::text 
  AND (
    public.is_admin((SELECT auth.uid()))
    OR
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.auth_id = (SELECT auth.uid())
        AND users.id = public.extract_tutor_id_from_path_bigint(storage.objects.name)
    )
  )
);
```

**tutors_policy_insert:**
```sql
ALTER POLICY "tutors_policy_insert" ON storage.objects
WITH CHECK (
  bucket_id = 'tutors'::text 
  AND (
    public.is_admin((SELECT auth.uid()))
    OR
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.auth_id = (SELECT auth.uid())
        AND users.id = public.extract_tutor_id_from_path_bigint(storage.objects.name)
    )
  )
);
```

**tutors_policy_update:**
```sql
ALTER POLICY "tutors_policy_update" ON storage.objects
USING (
  bucket_id = 'tutors'::text 
  AND (
    public.is_admin((SELECT auth.uid()))
    OR
    EXISTS (
      SELECT 1 FROM public.users 
      WHERE users.auth_id = (SELECT auth.uid())
        AND users.id = public.extract_tutor_id_from_path_bigint(storage.objects.name)
    )
  )
);
```

**3. Após atualizar, validar:**
```sql
-- Verificar que a nova função existe e retorna bigint
SELECT 
  proname as function_name,
  pg_get_function_result(oid) as return_type
FROM pg_proc 
WHERE pronamespace = 'public'::regnamespace 
  AND proname = 'extract_tutor_id_from_path_bigint';

-- Testar a nova função
SELECT 
  'tutors/123/arquivo.pdf' as test_path,
  public.extract_tutor_id_from_path_bigint('tutors/123/arquivo.pdf') as extracted_id,
  pg_typeof(public.extract_tutor_id_from_path_bigint('tutors/123/arquivo.pdf')) as id_type;

-- Verificar que as políticas usam a nova função
SELECT 
  p.polname as policy_name,
  pg_get_expr(p.qual, p.polrelid) as stored_using_expression,
  pg_get_expr(p.polwithcheck, p.polrelid) as stored_with_check_expression
FROM pg_policy p
JOIN pg_class c ON c.oid = p.polrelid
WHERE c.relname = 'objects'
  AND c.relnamespace = 'storage'::regnamespace
  AND p.polname IN (
    'staff_policy_select',
    'tutors_policy_select',
    'tutors_policy_insert',
    'tutors_policy_update'
  )
ORDER BY p.polname;
```

**4. Após validação bem-sucedida, opcionalmente remover a função antiga:**
```sql
DROP FUNCTION IF EXISTS public.extract_tutor_id_from_path(text);
```

**Verificar que:**
- ✅ Nova função criada e retorna `bigint`
- ✅ Todas as 4 políticas usam a nova função
- ✅ Nenhuma política usa a função antiga
- ✅ Sistema RLS funcionando corretamente

Pode prosseguir com a criação da nova função e migração das políticas?


